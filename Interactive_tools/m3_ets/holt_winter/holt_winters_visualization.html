<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holt-Winters Method (Additive Seasonality) - Interactive Learning Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@2.27.0/dist/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }
        
        .equations-panel {
            background: #f8f9fa;
            padding: 25px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .equations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
        }
        
        .equation-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .equation-box h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .equation {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #333;
            text-align: center;
            padding: 12px;
            background: #f0f0f0;
            border-radius: 5px;
            margin: 8px 0;
        }
        
        .equation-description {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 8px;
        }
        
        .controls-panel {
            padding: 30px;
            background: white;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-section {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .control-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .control-group {
            flex: 1;
            min-width: 180px;
            max-width: 250px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 1em;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .value-display {
            min-width: 60px;
            padding: 6px 10px;
            background: #667eea;
            color: white;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            font-size: 0.95em;
        }
        
        .seasonal-inputs {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .seasonal-input {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .seasonal-input label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 4px;
        }
        
        .seasonal-input input {
            width: 100%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 0.95em;
        }
        
        .seasonal-input input:focus {
            border-color: #667eea;
            outline: none;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        button {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .visualization-panel {
            padding: 30px;
            background: white;
        }
        
        .chart-container {
            margin-bottom: 25px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .info-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .info-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .info-card h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        .info-card .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #333;
        }
        
        .iteration-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .iteration-info h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .math-step {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            overflow-x: auto;
            font-size: 0.9em;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .comparison-box {
            background: #e8f4fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .comparison-box h4 {
            color: #1976D2;
            margin-bottom: 10px;
        }
        
        .trend-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 1.5em;
        }
        
        .trend-up {
            color: #28a745;
        }
        
        .trend-down {
            color: #dc3545;
        }
        
        .trend-flat {
            color: #ffc107;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .animating {
            animation: pulse 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 Holt-Winters Method (Additive Seasonality)</h1>
            <p>Interactive Learning Tool - Understanding Level, Trend, and Seasonal Components</p>
        </div>
        
        <div class="equations-panel">
            <div class="equations-grid">
                <div class="equation-box">
                    <h3>🎯 Forecast Equation</h3>
                    <div class="equation">ŷ<sub>t+h|t</sub> = ℓ<sub>t</sub> + h·b<sub>t</sub> + s<sub>t+h-m(k+1)</sub></div>
                    <div class="equation-description">
                        Level + Trend + Seasonal component
                    </div>
                </div>
                
                <div class="equation-box">
                    <h3>📊 Level Equation</h3>
                    <div class="equation">ℓ<sub>t</sub> = α·(y<sub>t</sub> - s<sub>t-m</sub>) + (1-α)·(ℓ<sub>t-1</sub> + b<sub>t-1</sub>)</div>
                    <div class="equation-description">
                        Deseasonalized smoothing
                    </div>
                </div>
                
                <div class="equation-box">
                    <h3>📈 Trend Equation</h3>
                    <div class="equation">b<sub>t</sub> = β*·(ℓ<sub>t</sub> - ℓ<sub>t-1</sub>) + (1-β*)·b<sub>t-1</sub></div>
                    <div class="equation-description">
                        Trend smoothing (same as Holt)
                    </div>
                </div>
                
                <div class="equation-box">
                    <h3>🌊 Seasonal Equation</h3>
                    <div class="equation">s<sub>t</sub> = γ·(y<sub>t</sub> - ℓ<sub>t-1</sub> - b<sub>t-1</sub>) + (1-γ)·s<sub>t-m</sub></div>
                    <div class="equation-description">
                        Updates seasonal factor for current period
                    </div>
                </div>
            </div>
        </div>
        
        <div class="comparison-box">
            <h4>🔍 Holt-Winters: The Complete Model</h4>
            <p><strong>SES:</strong> Only level → Flat forecasts</p>
            <p><strong>Holt:</strong> Level + Trend → Linear forecasts</p>
            <p><strong>Holt-Winters:</strong> Level + Trend + Seasonality → Captures repeating patterns!</p>
        </div>
        
        <div class="controls-panel">
            <div class="control-section">
                <h3>⚙️ Smoothing Parameters</h3>
                <div class="control-row">
                    <div class="control-group">
                        <label for="alpha">α (Level)</label>
                        <div class="slider-container">
                            <input type="range" id="alpha" min="0.01" max="0.99" step="0.01" value="0.3">
                            <span class="value-display" id="alphaValue">0.30</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="betaStar">β* (Trend)</label>
                        <div class="slider-container">
                            <input type="range" id="betaStar" min="0" max="0.99" step="0.01" value="0.1">
                            <span class="value-display" id="betaStarValue">0.10</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="gamma">γ (Seasonal)</label>
                        <div class="slider-container">
                            <input type="range" id="gamma" min="0.01" max="0.99" step="0.01" value="0.2">
                            <span class="value-display" id="gammaValue">0.20</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>📈 Initial Level and Trend</h3>
                <div class="control-row">
                    <div class="control-group">
                        <label for="l0">Initial Level (ℓ₀)</label>
                        <div class="slider-container">
                            <input type="range" id="l0" min="50" max="200" step="1" value="112">
                            <span class="value-display" id="l0Value">112</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="b0">Initial Trend (b₀)</label>
                        <div class="slider-container">
                            <input type="range" id="b0" min="-5" max="10" step="0.1" value="2">
                            <span class="value-display" id="b0Value">2.0</span>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="speed">Animation Speed</label>
                        <div class="slider-container">
                            <input type="range" id="speed" min="100" max="2000" step="100" value="500">
                            <span class="value-display" id="speedValue">500ms</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>🌊 Initial Seasonal Components (s<sub>-11</sub> to s<sub>0</sub>)</h3>
                <div class="seasonal-inputs">
                    <div class="seasonal-input">
                        <label>s<sub>-11</sub> (Jan)</label>
                        <input type="number" id="s_minus11" value="-20" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-10</sub> (Feb)</label>
                        <input type="number" id="s_minus10" value="-15" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-9</sub> (Mar)</label>
                        <input type="number" id="s_minus9" value="5" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-8</sub> (Apr)</label>
                        <input type="number" id="s_minus8" value="10" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-7</sub> (May)</label>
                        <input type="number" id="s_minus7" value="8" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-6</sub> (Jun)</label>
                        <input type="number" id="s_minus6" value="15" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-5</sub> (Jul)</label>
                        <input type="number" id="s_minus5" value="30" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-4</sub> (Aug)</label>
                        <input type="number" id="s_minus4" value="35" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-3</sub> (Sep)</label>
                        <input type="number" id="s_minus3" value="20" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-2</sub> (Oct)</label>
                        <input type="number" id="s_minus2" value="0" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>-1</sub> (Nov)</label>
                        <input type="number" id="s_minus1" value="-15" step="1">
                    </div>
                    <div class="seasonal-input">
                        <label>s<sub>0</sub> (Dec)</label>
                        <input type="number" id="s_0" value="-10" step="1">
                    </div>
                </div>
                <button class="btn-info" onclick="estimateInitialSeasonals()" style="margin-top: 10px;">
                    🔮 Auto-estimate Initial Seasonals
                </button>
            </div>
        </div>
        
        <div class="button-group">
            <button class="btn-primary" onclick="startAnimation()">🎬 Start Animation</button>
            <button class="btn-secondary" onclick="pauseAnimation()">⏸️ Pause</button>
            <button class="btn-secondary" onclick="resetVisualization()">🔄 Reset</button>
            <button class="btn-primary" onclick="showFullFit()">⚡ Show Complete Fit</button>
        </div>
        
        <div class="visualization-panel">
            <div class="iteration-info" id="iterationInfo" style="display: none;">
                <h3>Current Iteration Details</h3>
                <div id="iterationDetails"></div>
            </div>
            
            <div class="chart-container">
                <div id="mainChart"></div>
            </div>
            
            <div class="chart-container">
                <div id="levelChart"></div>
            </div>
            
            <div class="chart-container">
                <div id="trendChart"></div>
            </div>
            
            <div class="chart-container">
                <div id="seasonalChart"></div>
            </div>
            
            <div class="info-cards">
                <div class="info-card">
                    <h4>Time Step</h4>
                    <div class="value" id="currentStep">0</div>
                </div>
                <div class="info-card">
                    <h4>Current Level</h4>
                    <div class="value" id="currentLevel">-</div>
                </div>
                <div class="info-card">
                    <h4>Current Trend</h4>
                    <div class="value">
                        <span id="currentTrend">-</span>
                        <span id="trendIndicator" class="trend-indicator"></span>
                    </div>
                </div>
                <div class="info-card">
                    <h4>Current Season</h4>
                    <div class="value" id="currentSeason">-</div>
                </div>
                <div class="info-card">
                    <h4>Training RMSE</h4>
                    <div class="value" id="trainRMSE">-</div>
                </div>
                <div class="info-card">
                    <h4>Test RMSE</h4>
                    <div class="value" id="testRMSE">-</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Airline passenger data (monthly from 1949 to 1960)
        const airlineData = [
            112, 118, 132, 129, 121, 135, 148, 148, 136, 119, 104, 118,
            115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, 140,
            145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166,
            171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194,
            196, 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201,
            204, 188, 235, 227, 234, 264, 302, 293, 259, 229, 203, 229,
            242, 233, 267, 269, 270, 315, 364, 347, 312, 274, 237, 278,
            284, 277, 317, 313, 318, 374, 413, 405, 355, 306, 271, 306,
            315, 301, 356, 348, 355, 422, 465, 467, 404, 347, 305, 336,
            340, 318, 362, 348, 363, 435, 491, 505, 404, 359, 310, 337,
            360, 342, 406, 396, 420, 472, 548, 559, 463, 407, 362, 405,
            417, 391, 419, 461, 472, 535, 622, 606, 508, 461, 390, 432
        ];
        
        // Create time index
        const timeIndex = Array.from({length: airlineData.length}, (_, i) => i + 1);
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // Split data into train and test (80/20 split)
        const splitIndex = Math.floor(airlineData.length * 0.8);
        const trainData = airlineData.slice(0, splitIndex);
        const testData = airlineData.slice(splitIndex);
        const trainTime = timeIndex.slice(0, splitIndex);
        const testTime = timeIndex.slice(splitIndex);
        
        // Global variables for animation
        let animationId = null;
        let currentIteration = 0;
        let levels = [];
        let trends = [];
        let seasonals = [];
        let forecasts = [];
        let alpha = 0.3;
        let betaStar = 0.1;
        let gamma = 0.2;
        let l0 = 112;
        let b0 = 2;
        let initialSeasonals = [];
        const m = 12; // Period for monthly data
        
        // Initialize controls
        document.getElementById('alpha').addEventListener('input', function(e) {
            alpha = parseFloat(e.target.value);
            document.getElementById('alphaValue').textContent = alpha.toFixed(2);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('betaStar').addEventListener('input', function(e) {
            betaStar = parseFloat(e.target.value);
            document.getElementById('betaStarValue').textContent = betaStar.toFixed(2);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('gamma').addEventListener('input', function(e) {
            gamma = parseFloat(e.target.value);
            document.getElementById('gammaValue').textContent = gamma.toFixed(2);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('l0').addEventListener('input', function(e) {
            l0 = parseFloat(e.target.value);
            document.getElementById('l0Value').textContent = l0;
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('b0').addEventListener('input', function(e) {
            b0 = parseFloat(e.target.value);
            document.getElementById('b0Value').textContent = b0.toFixed(1);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('speed').addEventListener('input', function(e) {
            document.getElementById('speedValue').textContent = e.target.value + 'ms';
        });
        
        // Get initial seasonal values from inputs
        function getInitialSeasonals() {
            const seasonals = [];
            for (let i = -11; i <= 0; i++) {
                const inputId = i === 0 ? 's_0' : `s_minus${Math.abs(i)}`;
                const value = parseFloat(document.getElementById(inputId).value) || 0;
                seasonals.push(value);
            }
            return seasonals;
        }
        
        // Estimate initial seasonals from first year of data
        function estimateInitialSeasonals() {
            if (airlineData.length < 12) {
                alert('Need at least 12 data points to estimate seasonals');
                return;
            }
            
            // Calculate average of first year
            const firstYear = airlineData.slice(0, 12);
            const average = firstYear.reduce((a, b) => a + b, 0) / 12;
            
            // Calculate seasonal deviations
            const seasonals = firstYear.map(val => (val - average).toFixed(0));
            
            // Update input fields
            for (let i = 0; i < 12; i++) {
                const inputId = i === 11 ? 's_0' : `s_minus${11 - i}`;
                document.getElementById(inputId).value = seasonals[i];
            }
            
            if (currentIteration > 0) {
                resetVisualization();
            }
        }
        
        function animateStep() {
            if (currentIteration >= trainData.length) {
                // Start forecasting phase
                if (currentIteration < trainData.length + testData.length) {
                    updateTestForecast();
                } else {
                    pauseAnimation();
                    showMetrics();
                }
                return;
            }
            
            const t = currentIteration;
            const y_t = trainData[t];
            
            // Get previous components
            let l_prev, b_prev, s_prev;
            if (t === 0) {
                l_prev = l0;
                b_prev = b0;
                s_prev = initialSeasonals[initialSeasonals.length - m]; // s_{-12}
            } else {
                l_prev = levels[t - 1];
                b_prev = trends[t - 1];
                // Get seasonal from m periods ago
                if (t >= m) {
                    s_prev = seasonals[t - m];
                } else {
                    // Use initial seasonal
                    s_prev = initialSeasonals[initialSeasonals.length - m + t];
                }
            }
            
            // Calculate forecast BEFORE updating (using previous level, trend, and seasonal from last year)
            const forecast = l_prev + b_prev + s_prev;
            forecasts.push(forecast);
            
            // Update level (deseasonalized)
            const l_t = alpha * (y_t - s_prev) + (1 - alpha) * (l_prev + b_prev);
            
            // Update trend
            const b_t = betaStar * (l_t - l_prev) + (1 - betaStar) * b_prev;
            
            // Update seasonal
            const s_t = gamma * (y_t - l_prev - b_prev) + (1 - gamma) * s_prev;
            
            levels.push(l_t);
            trends.push(b_t);
            seasonals.push(s_t);
            
            // Update charts
            updateCharts();
            
            // Update iteration info
            updateIterationInfo(t, y_t, l_prev, b_prev, s_prev, l_t, b_t, s_t, forecast);
            
            // Update info cards
            updateInfoCards(t + 1, l_t, b_t, s_t);
            
            currentIteration++;
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animateStep, speed);
        }
        
        function updateIterationInfo(t, y_t, l_prev, b_prev, s_prev, l_t, b_t, s_t, forecast) {
            const info = document.getElementById('iterationInfo');
            const details = document.getElementById('iterationDetails');
            
            info.style.display = 'block';
            info.classList.add('animating');
            
            const monthIdx = t % 12;
            const monthName = monthNames[monthIdx];
            
            details.innerHTML = `
                <div class="math-step">
                    <strong>Time t = ${t + 1} (${monthName})</strong>, Actual value y<sub>${t + 1}</sub> = ${y_t}
                </div>
                <div class="math-step">
                    <strong>Step 1 - Forecast:</strong> ŷ<sub>${t + 1}|${t}</sub> = ℓ<sub>${t}</sub> + b<sub>${t}</sub> + s<sub>${t + 1 - m}</sub>
                </div>
                <div class="math-step">
                    ŷ<sub>${t + 1}|${t}</sub> = ${l_prev.toFixed(1)} + ${b_prev.toFixed(1)} + ${s_prev.toFixed(1)} = <span class="highlight">${forecast.toFixed(1)}</span>
                </div>
                <div class="math-step">
                    <strong>Step 2 - Update Level:</strong> ℓ<sub>${t + 1}</sub> = α·(y<sub>${t + 1}</sub> - s<sub>${t + 1 - m}</sub>) + (1-α)·(ℓ<sub>${t}</sub> + b<sub>${t}</sub>)
                </div>
                <div class="math-step">
                    ℓ<sub>${t + 1}</sub> = ${alpha.toFixed(2)} × (${y_t} - ${s_prev.toFixed(1)}) + ${(1 - alpha).toFixed(2)} × (${l_prev.toFixed(1)} + ${b_prev.toFixed(1)})
                </div>
                <div class="math-step">
                    ℓ<sub>${t + 1}</sub> = ${(alpha * (y_t - s_prev)).toFixed(1)} + ${((1 - alpha) * (l_prev + b_prev)).toFixed(1)} = <span class="highlight">${l_t.toFixed(1)}</span>
                </div>
                <div class="math-step">
                    <strong>Step 3 - Update Trend:</strong> b<sub>${t + 1}</sub> = β*·(ℓ<sub>${t + 1}</sub> - ℓ<sub>${t}</sub>) + (1-β*)·b<sub>${t}</sub>
                </div>
                <div class="math-step">
                    b<sub>${t + 1}</sub> = ${betaStar.toFixed(2)} × (${l_t.toFixed(1)} - ${l_prev.toFixed(1)}) + ${(1 - betaStar).toFixed(2)} × ${b_prev.toFixed(1)}
                </div>
                <div class="math-step">
                    b<sub>${t + 1}</sub> = ${(betaStar * (l_t - l_prev)).toFixed(2)} + ${((1 - betaStar) * b_prev).toFixed(2)} = <span class="highlight">${b_t.toFixed(2)}</span>
                </div>
                <div class="math-step">
                    <strong>Step 4 - Update Seasonal:</strong> s<sub>${t + 1}</sub> = γ·(y<sub>${t + 1}</sub> - ℓ<sub>${t}</sub> - b<sub>${t}</sub>) + (1-γ)·s<sub>${t + 1 - m}</sub>
                </div>
                <div class="math-step">
                    s<sub>${t + 1}</sub> = ${gamma.toFixed(2)} × (${y_t} - ${l_prev.toFixed(1)} - ${b_prev.toFixed(1)}) + ${(1 - gamma).toFixed(2)} × ${s_prev.toFixed(1)}
                </div>
                <div class="math-step">
                    s<sub>${t + 1}</sub> = ${(gamma * (y_t - l_prev - b_prev)).toFixed(1)} + ${((1 - gamma) * s_prev).toFixed(1)} = <span class="highlight">${s_t.toFixed(1)}</span>
                </div>
            `;
            
            setTimeout(() => info.classList.remove('animating'), 500);
        }
        
        function updateTestForecast() {
            const testIndex = currentIteration - trainData.length;
            const h = testIndex + 1;  // Horizon (1, 2, 3, ...)
            const lastLevel = levels[levels.length - 1];
            const lastTrend = trends[trends.length - 1];
            
            // Which month are we forecasting? (0=Jan, 1=Feb, ..., 11=Dec)
            const forecastMonth = (trainData.length + testIndex) % m;
            
            // Find the LAST occurrence of this month in the training period
            // We need to go back from the end of training to find the most recent seasonal for this month
            let seasonal;
            
            // Search backwards through the training period for the last update of this month
            for (let i = trainData.length - 1; i >= 0; i--) {
                if (i % m === forecastMonth) {
                    // Found the last occurrence of this month in training
                    if (i < seasonals.length) {
                        seasonal = seasonals[i];
                    } else {
                        // Use initial seasonal if we haven't reached this month yet
                        seasonal = initialSeasonals[forecastMonth];
                    }
                    break;
                }
            }
            
            // Fallback to initial seasonal if not found
            if (seasonal === undefined) {
                seasonal = initialSeasonals[forecastMonth];
            }
            
            // For Holt-Winters, forecast h steps ahead uses: l_t + h * b_t + s_{t+h-m}
            const forecast = lastLevel + h * lastTrend + seasonal;
            forecasts.push(forecast);
            
            updateCharts();
            
            document.getElementById('currentStep').textContent = currentIteration + 1;
            currentIteration++;
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animateStep, speed);
        }
        
        function updateInfoCards(step, level, trend, seasonal) {
            document.getElementById('currentStep').textContent = step;
            document.getElementById('currentLevel').textContent = level ? level.toFixed(1) : '-';
            document.getElementById('currentTrend').textContent = trend ? trend.toFixed(2) : '-';
            document.getElementById('currentSeason').textContent = seasonal ? seasonal.toFixed(1) : '-';
            
            // Update trend indicator
            const indicator = document.getElementById('trendIndicator');
            if (trend > 0.5) {
                indicator.textContent = '↗';
                indicator.className = 'trend-indicator trend-up';
            } else if (trend < -0.5) {
                indicator.textContent = '↘';
                indicator.className = 'trend-indicator trend-down';
            } else {
                indicator.textContent = '→';
                indicator.className = 'trend-indicator trend-flat';
            }
        }
        
        function updateCharts() {
            // Get data to show
            const trainForecastsToShow = forecasts.slice(0, Math.min(forecasts.length, trainData.length));
            const testForecastsToShow = forecasts.slice(trainData.length);
            const levelsToShow = levels;
            const trendsToShow = trends;
            const seasonalsToShow = seasonals;
            
            // Main chart
            const traces = [
                {
                    x: trainTime,
                    y: trainData,
                    mode: 'lines+markers',
                    name: 'Training Data',
                    line: { color: 'blue', width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: testTime,
                    y: testData,
                    mode: 'lines+markers',
                    name: 'Test Data',
                    line: { color: 'lightblue', width: 2, dash: 'dash' },
                    marker: { size: 4 }
                },
                {
                    x: trainTime.slice(0, trainForecastsToShow.length),
                    y: trainForecastsToShow,
                    mode: 'lines+markers',
                    name: 'Fitted Values',
                    line: { color: 'red', width: 2 },
                    marker: { size: 6, symbol: 'circle-open' }
                }
            ];
            
            if (testForecastsToShow.length > 0) {
                traces.push({
                    x: testTime.slice(0, testForecastsToShow.length),
                    y: testForecastsToShow,
                    mode: 'lines+markers',
                    name: 'Forecasts (with seasonality!)',
                    line: { color: 'orange', width: 2 },
                    marker: { size: 6, symbol: 'square-open' }
                });
            }
            
            const layout1 = {
                title: 'Airline Passengers - Holt-Winters Method (Additive)',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Number of Passengers' },
                showlegend: true,
                height: 400,
                hovermode: 'x'
            };
            
            Plotly.newPlot('mainChart', traces, layout1);
            
            // Level evolution chart
            const levelXValues = levelsToShow.length > 0 ? [0, ...trainTime.slice(0, levelsToShow.length)] : [0];
            const levelYValues = levelsToShow.length > 0 ? [l0, ...levelsToShow] : [l0];
            
            const levelTrace = {
                x: levelXValues,
                y: levelYValues,
                mode: 'lines+markers',
                name: 'Level Component (ℓ_t)',
                line: { color: 'purple', width: 3 },
                marker: { size: 8, color: 'purple' },
                fill: 'tonexty',
                fillcolor: 'rgba(147, 112, 219, 0.1)'
            };
            
            const layout2 = {
                title: 'Level Component Evolution (ℓ_t) - Deseasonalized',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Level Value' },
                showlegend: true,
                height: 350,
                annotations: []
            };
            
            // Add annotations
            layout2.annotations.push({
                x: 0,
                y: l0,
                xref: 'x',
                yref: 'y',
                text: `ℓ₀ = ${l0.toFixed(1)}`,
                showarrow: true,
                arrowhead: 7,
                ax: -40,
                ay: 40,
                bgcolor: 'purple',
                bordercolor: 'purple',
                borderwidth: 2,
                font: { color: 'white', size: 10 }
            });
            
            if (levelsToShow.length > 0) {
                layout2.annotations.push({
                    x: trainTime[levelsToShow.length - 1],
                    y: levelsToShow[levelsToShow.length - 1],
                    xref: 'x',
                    yref: 'y',
                    text: `ℓ_${levelsToShow.length} = ${levelsToShow[levelsToShow.length - 1].toFixed(1)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: -50,
                    ay: -40,
                    bgcolor: 'purple',
                    bordercolor: 'purple',
                    borderwidth: 2,
                    font: { color: 'white', size: 10 }
                });
            }
            
            Plotly.newPlot('levelChart', [levelTrace], layout2);
            
            // Trend evolution chart
            const trendXValues = trendsToShow.length > 0 ? [0, ...trainTime.slice(0, trendsToShow.length)] : [0];
            const trendYValues = trendsToShow.length > 0 ? [b0, ...trendsToShow] : [b0];
            
            const trendTrace = {
                x: trendXValues,
                y: trendYValues,
                mode: 'lines+markers',
                name: 'Trend Component (b_t)',
                line: { color: 'green', width: 3 },
                marker: { size: 8, color: 'green' },
                fill: 'tozeroy',
                fillcolor: 'rgba(76, 175, 80, 0.1)'
            };
            
            const layout3 = {
                title: 'Trend Component Evolution (b_t)',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Trend Value', zeroline: true },
                showlegend: true,
                height: 350,
                shapes: [{
                    type: 'line',
                    x0: 0,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: []
            };
            
            layout3.annotations.push({
                x: 0,
                y: b0,
                xref: 'x',
                yref: 'y',
                text: `b₀ = ${b0.toFixed(2)}`,
                showarrow: true,
                arrowhead: 7,
                ax: 40,
                ay: -40,
                bgcolor: 'green',
                bordercolor: 'green',
                borderwidth: 2,
                font: { color: 'white', size: 10 }
            });
            
            if (trendsToShow.length > 0) {
                layout3.annotations.push({
                    x: trainTime[trendsToShow.length - 1],
                    y: trendsToShow[trendsToShow.length - 1],
                    xref: 'x',
                    yref: 'y',
                    text: `b_${trendsToShow.length} = ${trendsToShow[trendsToShow.length - 1].toFixed(2)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 50,
                    ay: -40,
                    bgcolor: 'green',
                    bordercolor: 'green',
                    borderwidth: 2,
                    font: { color: 'white', size: 10 }
                });
            }
            
            Plotly.newPlot('trendChart', [trendTrace], layout3);
            
            // Seasonal evolution chart
            // Combine initial seasonals and updated seasonals
            const allSeasonals = [...initialSeasonals, ...seasonalsToShow];
            const seasonalXValues = [];
            const seasonalYValues = [];
            const seasonalColors = [];
            
            // Add initial seasonals at negative indices
            for (let i = 0; i < initialSeasonals.length; i++) {
                seasonalXValues.push(i - initialSeasonals.length + 1);
                seasonalYValues.push(initialSeasonals[i]);
                seasonalColors.push('lightblue');
            }
            
            // Add updated seasonals
            for (let i = 0; i < seasonalsToShow.length; i++) {
                seasonalXValues.push(trainTime[i]);
                seasonalYValues.push(seasonalsToShow[i]);
                seasonalColors.push('orange');
            }
            
            const seasonalTrace = {
                x: seasonalXValues,
                y: seasonalYValues,
                mode: 'lines+markers',
                name: 'Seasonal Components (s_t)',
                line: { color: 'orange', width: 2 },
                marker: { 
                    size: 6, 
                    color: seasonalColors,
                    line: { color: 'darkorange', width: 1 }
                }
            };
            
            const layout4 = {
                title: 'Seasonal Component Evolution (s_t) - 12 Month Pattern',
                xaxis: { 
                    title: 'Time (Months)',
                    range: [-12, Math.max(trainData.length, 12)]
                },
                yaxis: { title: 'Seasonal Value', zeroline: true },
                showlegend: true,
                height: 350,
                shapes: [{
                    type: 'line',
                    x0: -12,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: [{
                    x: -6,
                    y: Math.max(...initialSeasonals) + 10,
                    text: 'Initial Seasonals',
                    showarrow: false,
                    font: { color: 'blue', size: 12 }
                }]
            };
            
            if (seasonalsToShow.length > 0) {
                const lastSeasonIdx = seasonalsToShow.length - 1;
                const monthIdx = lastSeasonIdx % 12;
                layout4.annotations.push({
                    x: trainTime[lastSeasonIdx],
                    y: seasonalsToShow[lastSeasonIdx],
                    xref: 'x',
                    yref: 'y',
                    text: `s_${lastSeasonIdx + 1} (${monthNames[monthIdx]}) = ${seasonalsToShow[lastSeasonIdx].toFixed(1)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 50,
                    ay: -30,
                    bgcolor: 'orange',
                    bordercolor: 'orange',
                    borderwidth: 2,
                    font: { color: 'white', size: 10 }
                });
            }
            
            Plotly.newPlot('seasonalChart', [seasonalTrace], layout4);
            
            // Calculate and display metrics
            if (trainForecastsToShow.length > 0) {
                const trainErrors = trainForecastsToShow.map((f, i) => Math.pow(trainData[i] - f, 2));
                const trainRMSE = Math.sqrt(trainErrors.reduce((a, b) => a + b, 0) / trainErrors.length);
                document.getElementById('trainRMSE').textContent = trainRMSE.toFixed(1);
            }
            
            if (testForecastsToShow.length > 0) {
                const testErrors = testForecastsToShow.map((f, i) => Math.pow(testData[i] - f, 2));
                const testRMSE = Math.sqrt(testErrors.reduce((a, b) => a + b, 0) / testErrors.length);
                document.getElementById('testRMSE').textContent = testRMSE.toFixed(1);
            }
        }
        
        function startAnimation() {
            if (animationId) {
                pauseAnimation();
            }
            if (currentIteration === 0 || currentIteration >= trainData.length + testData.length) {
                resetVisualization();
            }
            initialSeasonals = getInitialSeasonals();
            animateStep();
        }
        
        function pauseAnimation() {
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        }
        
        function resetVisualization() {
            pauseAnimation();
            currentIteration = 0;
            levels = [];
            trends = [];
            seasonals = [];
            forecasts = [];
            initialSeasonals = getInitialSeasonals();
            
            document.getElementById('currentStep').textContent = '0';
            document.getElementById('currentLevel').textContent = '-';
            document.getElementById('currentTrend').textContent = '-';
            document.getElementById('currentSeason').textContent = '-';
            document.getElementById('trendIndicator').textContent = '';
            document.getElementById('trainRMSE').textContent = '-';
            document.getElementById('testRMSE').textContent = '-';
            document.getElementById('iterationInfo').style.display = 'none';
            
            initializeCharts();
        }
        
        function showFullFit() {
            pauseAnimation();
            resetVisualization();
            
            // Get initial seasonals
            initialSeasonals = getInitialSeasonals();
            
            // Clear arrays
            levels = [];
            trends = [];
            seasonals = [];
            forecasts = [];
            
            // Calculate full fit for training data
            for (let t = 0; t < trainData.length; t++) {
                const y_t = trainData[t];
                
                // Get previous components
                let l_prev, b_prev, s_prev;
                if (t === 0) {
                    l_prev = l0;
                    b_prev = b0;
                    s_prev = initialSeasonals[initialSeasonals.length - m];
                } else {
                    l_prev = levels[t - 1];
                    b_prev = trends[t - 1];
                    if (t >= m) {
                        s_prev = seasonals[t - m];
                    } else {
                        s_prev = initialSeasonals[initialSeasonals.length - m + t];
                    }
                }
                
                // Forecast
                forecasts.push(l_prev + b_prev + s_prev);
                
                // Update components
                const l_t = alpha * (y_t - s_prev) + (1 - alpha) * (l_prev + b_prev);
                const b_t = betaStar * (l_t - l_prev) + (1 - betaStar) * b_prev;
                const s_t = gamma * (y_t - l_prev - b_prev) + (1 - gamma) * s_prev;
                
                levels.push(l_t);
                trends.push(b_t);
                seasonals.push(s_t);
            }
            
            // Add test forecasts
            const lastLevel = levels[levels.length - 1];
            const lastTrend = trends[trends.length - 1];
            
            for (let h = 1; h <= testData.length; h++) {
                // Which month are we forecasting? (0=Jan, 1=Feb, ..., 11=Dec)
                const forecastMonth = (trainData.length + h - 1) % m;
                
                // Find the LAST occurrence of this month in the training period
                let seasonal;
                
                // Search backwards through the training period for the last update of this month
                for (let i = trainData.length - 1; i >= 0; i--) {
                    if (i % m === forecastMonth) {
                        // Found the last occurrence of this month in training
                        if (i < seasonals.length) {
                            seasonal = seasonals[i];
                        } else {
                            seasonal = initialSeasonals[forecastMonth];
                        }
                        break;
                    }
                }
                
                // Fallback to initial seasonal if not found
                if (seasonal === undefined) {
                    seasonal = initialSeasonals[forecastMonth];
                }
                
                forecasts.push(lastLevel + h * lastTrend + seasonal);
            }
            
            currentIteration = trainData.length + testData.length;
            updateCharts();
            showMetrics();
            
            const lastSeasonal = seasonals[seasonals.length - 1];
            updateInfoCards(trainData.length, lastLevel, lastTrend, lastSeasonal);
        }
        
        function showMetrics() {
            const trainForecasts = forecasts.slice(0, trainData.length);
            const testForecasts = forecasts.slice(trainData.length);
            
            if (trainForecasts.length > 0) {
                const trainErrors = trainForecasts.map((f, i) => Math.pow(trainData[i] - f, 2));
                const trainRMSE = Math.sqrt(trainErrors.reduce((a, b) => a + b, 0) / trainErrors.length);
                document.getElementById('trainRMSE').textContent = trainRMSE.toFixed(1);
            }
            
            if (testForecasts.length > 0) {
                const testErrors = testForecasts.map((f, i) => Math.pow(testData[i] - f, 2));
                const testRMSE = Math.sqrt(testErrors.reduce((a, b) => a + b, 0) / testErrors.length);
                document.getElementById('testRMSE').textContent = testRMSE.toFixed(1);
            }
        }
        
        function initializeCharts() {
            // Main chart
            const traces1 = [
                {
                    x: trainTime,
                    y: trainData,
                    mode: 'lines+markers',
                    name: 'Training Data',
                    line: { color: 'blue', width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: testTime,
                    y: testData,
                    mode: 'lines+markers',
                    name: 'Test Data',
                    line: { color: 'lightblue', width: 2, dash: 'dash' },
                    marker: { size: 4 }
                }
            ];
            
            const layout1 = {
                title: 'Airline Passengers - Holt-Winters Method (Additive)',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Number of Passengers' },
                showlegend: true,
                height: 400
            };
            
            Plotly.newPlot('mainChart', traces1, layout1);
            
            // Level chart with initial value
            const levelTrace = {
                x: [0],
                y: [l0],
                mode: 'markers',
                name: 'Level Component (ℓ_t)',
                marker: { size: 10, color: 'purple' }
            };
            
            const layout2 = {
                title: 'Level Component Evolution (ℓ_t) - Deseasonalized',
                xaxis: { title: 'Time (Months)', range: [-1, trainData.length] },
                yaxis: { title: 'Level Value' },
                showlegend: true,
                height: 350,
                annotations: [{
                    x: 0,
                    y: l0,
                    xref: 'x',
                    yref: 'y',
                    text: `ℓ₀ = ${l0.toFixed(1)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: -40,
                    ay: 40,
                    bgcolor: 'purple',
                    bordercolor: 'purple',
                    borderwidth: 2,
                    font: { color: 'white', size: 10 }
                }]
            };
            
            Plotly.newPlot('levelChart', [levelTrace], layout2);
            
            // Trend chart with initial value
            const trendTrace = {
                x: [0],
                y: [b0],
                mode: 'markers',
                name: 'Trend Component (b_t)',
                marker: { size: 10, color: 'green' }
            };
            
            const layout3 = {
                title: 'Trend Component Evolution (b_t)',
                xaxis: { title: 'Time (Months)', range: [-1, trainData.length] },
                yaxis: { title: 'Trend Value' },
                showlegend: true,
                height: 350,
                shapes: [{
                    type: 'line',
                    x0: -1,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: [{
                    x: 0,
                    y: b0,
                    xref: 'x',
                    yref: 'y',
                    text: `b₀ = ${b0.toFixed(2)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 40,
                    ay: -40,
                    bgcolor: 'green',
                    bordercolor: 'green',
                    borderwidth: 2,
                    font: { color: 'white', size: 10 }
                }]
            };
            
            Plotly.newPlot('trendChart', [trendTrace], layout3);
            
            // Seasonal chart with initial values
            initialSeasonals = getInitialSeasonals();
            const seasonalXValues = [];
            const seasonalYValues = [];
            
            for (let i = 0; i < initialSeasonals.length; i++) {
                seasonalXValues.push(i - initialSeasonals.length + 1);
                seasonalYValues.push(initialSeasonals[i]);
            }
            
            const seasonalTrace = {
                x: seasonalXValues,
                y: seasonalYValues,
                mode: 'lines+markers',
                name: 'Initial Seasonals',
                line: { color: 'lightblue', width: 2 },
                marker: { size: 8, color: 'lightblue' }
            };
            
            const layout4 = {
                title: 'Seasonal Component Evolution (s_t) - 12 Month Pattern',
                xaxis: { 
                    title: 'Time (Months)',
                    range: [-12, Math.max(trainData.length, 12)]
                },
                yaxis: { title: 'Seasonal Value' },
                showlegend: true,
                height: 350,
                shapes: [{
                    type: 'line',
                    x0: -12,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: [{
                    x: -6,
                    y: Math.max(...initialSeasonals) + 10,
                    text: 'Initial Seasonals (s₋₁₁ to s₀)',
                    showarrow: false,
                    font: { color: 'blue', size: 12 }
                }]
            };
            
            Plotly.newPlot('seasonalChart', [seasonalTrace], layout4);
        }
        
        // Initialize on load
        initializeCharts();
    </script>
</body>
</html>