<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holt's Linear Trend Method - Interactive Learning Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/plotly.js@2.27.0/dist/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }
        
        .attribution {
            text-align: center;
            color: rgba(255,255,255,0.9);
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .header-links {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 25px;
        }
        
        .header-links a {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            color: white;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .header-links a:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .btn-website {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }
        
        .btn-youtube {
            background: linear-gradient(135deg, #ff0000, #cc0000);
        }
        
        .btn-github {
            background: linear-gradient(135deg, #333, #000);
        }
        
        .subtitle {
            text-align: center;
            color: rgba(255,255,255,0.9);
            margin-bottom: 0;
            font-size: 1.1em;
        }
        
        .equations-panel {
            background: #f8f9fa;
            padding: 25px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .equations-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .equation-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .equation-box h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .equation {
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            color: #333;
            text-align: center;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .equation-description {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
        }
        
        .controls-panel {
            padding: 30px;
            background: white;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-row {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
            max-width: 300px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 1.1em;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #667eea;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .value-display {
            min-width: 70px;
            padding: 8px 12px;
            background: #667eea;
            color: white;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            font-size: 1.1em;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }
        
        button {
            padding: 12px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
        }
        
        .visualization-panel {
            padding: 30px;
            background: white;
        }
        
        .chart-container {
            margin-bottom: 30px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .info-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .info-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .info-card h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .info-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #333;
        }
        
        .iteration-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .iteration-info h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .math-step {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            overflow-x: auto;
            font-size: 0.95em;
        }
        
        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .component-container {
            margin-bottom: 20px;
        }
        
        .trend-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 1.5em;
        }
        
        .trend-up {
            color: #28a745;
        }
        
        .trend-down {
            color: #dc3545;
        }
        
        .trend-flat {
            color: #ffc107;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .animating {
            animation: pulse 0.5s ease-in-out;
        }
        
        .comparison-box {
            background: #e8f4fd;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .comparison-box h4 {
            color: #1976D2;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 Holt's Linear Trend Method</h1>
            <p class="attribution">Created by Dr. Pedram Jahangiry | Enhanced with Claude</p>
            <div class="header-links">
                <a href="https://pjalgotrader.github.io/" target="_blank" class="btn-website">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm7.5-6.923c-.67.204-1.335.82-1.887 1.855A7.97 7.97 0 0 0 5.145 4H7.5V1.077zM4.09 4a9.267 9.267 0 0 1 .64-1.539 6.7 6.7 0 0 1 .597-.933A7.025 7.025 0 0 0 2.255 4H4.09zm-.582 3.5c.03-.877.138-1.718.312-2.5H1.674a6.958 6.958 0 0 0-.656 2.5h2.49zM4.847 5a12.5 12.5 0 0 0-.338 2.5H7.5V5H4.847zM8.5 5v2.5h2.99a12.495 12.495 0 0 0-.337-2.5H8.5zM4.51 8.5a12.5 12.5 0 0 0 .337 2.5H7.5V8.5H4.51zm3.99 0V11h2.653c.187-.765.306-1.608.338-2.5H8.5zM5.145 12c.138.386.295.744.468 1.068.552 1.035 1.218 1.65 1.887 1.855V12H5.145zm.182 2.472a6.696 6.696 0 0 1-.597-.933A9.268 9.268 0 0 1 4.09 12H2.255a7.024 7.024 0 0 0 3.072 2.472zM3.82 11a13.652 13.652 0 0 1-.312-2.5h-2.49c.062.89.291 1.733.656 2.5H3.82zm6.853 3.472A7.024 7.024 0 0 0 13.745 12H11.91a9.27 9.27 0 0 1-.64 1.539 6.688 6.688 0 0 1-.597.933zM8.5 12v2.923c.67-.204 1.335-.82 1.887-1.855.173-.324.33-.682.468-1.068H8.5zm3.68-1h2.146c.365-.767.594-1.61.656-2.5h-2.49a13.65 13.65 0 0 1-.312 2.5zm2.802-3.5a6.959 6.959 0 0 0-.656-2.5H12.18c.174.782.282 1.623.312 2.5h2.49zM11.27 2.461c.247.464.462.98.64 1.539h1.835a7.024 7.024 0 0 0-3.072-2.472c.218.284.418.598.597.933zM10.855 4a7.966 7.966 0 0 0-.468-1.068C9.835 1.897 9.17 1.282 8.5 1.077V4h2.355z"/>
                    </svg>
                    Website
                </a>
                <a href="https://www.youtube.com/@pedramjahangiry" target="_blank" class="btn-youtube">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31.4 31.4 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788 0 0 1 7.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/>
                    </svg>
                    YouTube Channel
                </a>
                <a href="https://github.com/PJalgotrader/" target="_blank" class="btn-github">
                    <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    GitHub Profile
                </a>
            </div>
            <p class="subtitle">Interactive Teaching Tool for Understanding Level and Trend Components</p>
        </div>
        
        <div class="equations-panel">
            <div class="equations-grid">
                <div class="equation-box">
                    <h3>🎯 Forecast Equation</h3>
                    <div class="equation">ŷ<sub>t+h|t</sub> = ℓ<sub>t</sub> + h·b<sub>t</sub></div>
                    <div class="equation-description">
                        Forecast = Level + (Horizon × Trend)
                    </div>
                </div>
                
                <div class="equation-box">
                    <h3>📊 Level Equation</h3>
                    <div class="equation">ℓ<sub>t</sub> = α·y<sub>t</sub> + (1-α)·(ℓ<sub>t-1</sub> + b<sub>t-1</sub>)</div>
                    <div class="equation-description">
                        Smooths between observation and one-step forecast
                    </div>
                </div>
                
                <div class="equation-box">
                    <h3>📈 Trend Equation</h3>
                    <div class="equation">b<sub>t</sub> = β*·(ℓ<sub>t</sub> - ℓ<sub>t-1</sub>) + (1-β*)·b<sub>t-1</sub></div>
                    <div class="equation-description">
                        Smooths the trend estimate
                    </div>
                </div>
            </div>
        </div>
        
        <div class="comparison-box">
            <h4>🔍 Holt vs SES: The Key Difference</h4>
            <p><strong>SES:</strong> Assumes data fluctuates around a constant level → Flat forecasts</p>
            <p><strong>Holt:</strong> Adds a trend component that captures direction → Sloped forecasts that can follow upward/downward patterns!</p>
        </div>
        
        <div class="controls-panel">
            <div class="control-row">
                <div class="control-group">
                    <label for="alpha">Level Smoothing (α)</label>
                    <div class="slider-container">
                        <input type="range" id="alpha" min="0.01" max="0.99" step="0.01" value="0.3">
                        <span class="value-display" id="alphaValue">0.30</span>
                    </div>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Weight for level updates
                    </small>
                </div>
                
                <div class="control-group">
                    <label for="betaStar">Trend Smoothing (β*)</label>
                    <div class="slider-container">
                        <input type="range" id="betaStar" min="0" max="0.99" step="0.01" value="0.1">
                        <span class="value-display" id="betaStarValue">0.10</span>
                    </div>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Weight for trend updates (0 = constant trend)
                    </small>
                </div>
            </div>
            
            <div class="control-row">
                <div class="control-group">
                    <label for="l0">Initial Level (ℓ₀)</label>
                    <div class="slider-container">
                        <input type="range" id="l0" min="50" max="200" step="1" value="112">
                        <span class="value-display" id="l0Value">112</span>
                    </div>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Starting level estimate
                    </small>
                </div>
                
                <div class="control-group">
                    <label for="b0">Initial Trend (b₀)</label>
                    <div class="slider-container">
                        <input type="range" id="b0" min="-5" max="10" step="0.1" value="2">
                        <span class="value-display" id="b0Value">2.0</span>
                    </div>
                    <small style="color: #666; margin-top: 5px; display: block;">
                        Starting trend estimate
                    </small>
                </div>
                
                <div class="control-group">
                    <label for="speed">Animation Speed</label>
                    <div class="slider-container">
                        <input type="range" id="speed" min="100" max="2000" step="100" value="500">
                        <span class="value-display" id="speedValue">500ms</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-group">
            <button class="btn-primary" onclick="startAnimation()">🎬 Start Animation</button>
            <button class="btn-secondary" onclick="pauseAnimation()">⏸️ Pause</button>
            <button class="btn-secondary" onclick="resetVisualization()">🔄 Reset</button>
            <button class="btn-primary" onclick="showFullFit()">⚡ Show Complete Fit</button>
        </div>
        
        <div class="visualization-panel">
            <div class="iteration-info" id="iterationInfo" style="display: none;">
                <h3>Current Iteration Details</h3>
                <div id="iterationDetails"></div>
            </div>
            
            <div class="chart-container">
                <div id="mainChart"></div>
            </div>
            
            <div class="component-container">
                <div class="chart-container">
                    <div id="levelChart"></div>
                </div>
                
                <div class="chart-container">
                    <div id="trendChart"></div>
                </div>
            </div>
            
            <div class="info-cards">
                <div class="info-card">
                    <h4>Time Step</h4>
                    <div class="value" id="currentStep">0</div>
                </div>
                <div class="info-card">
                    <h4>Current Level</h4>
                    <div class="value" id="currentLevel">-</div>
                </div>
                <div class="info-card">
                    <h4>Current Trend</h4>
                    <div class="value">
                        <span id="currentTrend">-</span>
                        <span id="trendIndicator" class="trend-indicator"></span>
                    </div>
                </div>
                <div class="info-card">
                    <h4>Training RMSE</h4>
                    <div class="value" id="trainRMSE">-</div>
                </div>
                <div class="info-card">
                    <h4>Test RMSE</h4>
                    <div class="value" id="testRMSE">-</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Airline passenger data (monthly from 1949 to 1960)
        const airlineData = [
            112, 118, 132, 129, 121, 135, 148, 148, 136, 119, 104, 118,
            115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, 140,
            145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166,
            171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194,
            196, 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201,
            204, 188, 235, 227, 234, 264, 302, 293, 259, 229, 203, 229,
            242, 233, 267, 269, 270, 315, 364, 347, 312, 274, 237, 278,
            284, 277, 317, 313, 318, 374, 413, 405, 355, 306, 271, 306,
            315, 301, 356, 348, 355, 422, 465, 467, 404, 347, 305, 336,
            340, 318, 362, 348, 363, 435, 491, 505, 404, 359, 310, 337,
            360, 342, 406, 396, 420, 472, 548, 559, 463, 407, 362, 405,
            417, 391, 419, 461, 472, 535, 622, 606, 508, 461, 390, 432
        ];
        
        // Create time index
        const timeIndex = Array.from({length: airlineData.length}, (_, i) => i + 1);
        
        // Split data into train and test (80/20 split)
        const splitIndex = Math.floor(airlineData.length * 0.8);
        const trainData = airlineData.slice(0, splitIndex);
        const testData = airlineData.slice(splitIndex);
        const trainTime = timeIndex.slice(0, splitIndex);
        const testTime = timeIndex.slice(splitIndex);
        
        // Global variables for animation
        let animationId = null;
        let currentIteration = 0;
        let levels = [];
        let trends = [];
        let forecasts = [];
        let alpha = 0.3;
        let betaStar = 0.1;
        let l0 = 112;
        let b0 = 2;
        
        // Initialize controls
        document.getElementById('alpha').addEventListener('input', function(e) {
            alpha = parseFloat(e.target.value);
            document.getElementById('alphaValue').textContent = alpha.toFixed(2);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('betaStar').addEventListener('input', function(e) {
            betaStar = parseFloat(e.target.value);
            document.getElementById('betaStarValue').textContent = betaStar.toFixed(2);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('l0').addEventListener('input', function(e) {
            l0 = parseFloat(e.target.value);
            document.getElementById('l0Value').textContent = l0;
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('b0').addEventListener('input', function(e) {
            b0 = parseFloat(e.target.value);
            document.getElementById('b0Value').textContent = b0.toFixed(1);
            if (currentIteration > 0) {
                resetVisualization();
            }
        });
        
        document.getElementById('speed').addEventListener('input', function(e) {
            document.getElementById('speedValue').textContent = e.target.value + 'ms';
        });
        
        function calculateHolt(data, alpha, betaStar, l0, b0) {
            let levels = [l0];
            let trends = [b0];
            let forecasts = [];
            
            for (let t = 0; t < data.length; t++) {
                // Forecast for time t is previous level + previous trend
                forecasts.push(levels[levels.length - 1] + trends[trends.length - 1]);
                
                // Update level
                const newLevel = alpha * data[t] + (1 - alpha) * (levels[levels.length - 1] + trends[trends.length - 1]);
                
                // Update trend
                const newTrend = betaStar * (newLevel - levels[levels.length - 1]) + (1 - betaStar) * trends[trends.length - 1];
                
                levels.push(newLevel);
                trends.push(newTrend);
            }
            
            return { levels, trends, forecasts };
        }
        
        function animateStep() {
            if (currentIteration >= trainData.length) {
                // Start forecasting phase
                if (currentIteration < trainData.length + testData.length) {
                    updateTestForecast();
                } else {
                    pauseAnimation();
                    showMetrics();
                }
                return;
            }
            
            const y_t = trainData[currentIteration];
            
            // Get previous level and trend
            let l_prev, b_prev;
            if (currentIteration === 0) {
                l_prev = l0;
                b_prev = b0;
            } else {
                l_prev = levels[currentIteration - 1];
                b_prev = trends[currentIteration - 1];
            }
            
            // Calculate forecast BEFORE updating (using previous level and trend)
            const forecast = l_prev + b_prev;
            forecasts.push(forecast);
            
            // NOW update level after observing y_t
            const l_t = alpha * y_t + (1 - alpha) * (l_prev + b_prev);
            
            // Update trend
            const b_t = betaStar * (l_t - l_prev) + (1 - betaStar) * b_prev;
            
            levels.push(l_t);
            trends.push(b_t);
            
            // Update charts AFTER adding the data
            updateCharts();
            
            // Update iteration info
            updateIterationInfo(currentIteration, y_t, l_prev, b_prev, l_t, b_t, forecast);
            
            // Update info cards
            updateInfoCards(currentIteration + 1, l_t, b_t);
            
            currentIteration++;
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animateStep, speed);
        }
        
        function updateIterationInfo(t, y_t, l_prev, b_prev, l_t, b_t, forecast) {
            const info = document.getElementById('iterationInfo');
            const details = document.getElementById('iterationDetails');
            
            info.style.display = 'block';
            info.classList.add('animating');
            
            details.innerHTML = `
                <div class="math-step">
                    <strong>Time t = ${t + 1}</strong>, Actual value y<sub>${t + 1}</sub> = ${y_t}
                </div>
                <div class="math-step">
                    <strong>Step 1 - Forecast:</strong> ŷ<sub>${t + 1}|${t}</sub> = ℓ<sub>${t}</sub> + b<sub>${t}</sub> = ${l_prev.toFixed(1)} + ${b_prev.toFixed(1)} = <span class="highlight">${forecast.toFixed(1)}</span>
                </div>
                <div class="math-step">
                    <strong>Step 2 - Update Level:</strong> ℓ<sub>${t + 1}</sub> = α·y<sub>${t + 1}</sub> + (1-α)·(ℓ<sub>${t}</sub> + b<sub>${t}</sub>)
                </div>
                <div class="math-step">
                    ℓ<sub>${t + 1}</sub> = ${alpha.toFixed(2)} × ${y_t} + ${(1 - alpha).toFixed(2)} × (${l_prev.toFixed(1)} + ${b_prev.toFixed(1)})
                </div>
                <div class="math-step">
                    ℓ<sub>${t + 1}</sub> = ${(alpha * y_t).toFixed(1)} + ${((1 - alpha) * (l_prev + b_prev)).toFixed(1)} = <span class="highlight">${l_t.toFixed(1)}</span>
                </div>
                <div class="math-step">
                    <strong>Step 3 - Update Trend:</strong> b<sub>${t + 1}</sub> = β*·(ℓ<sub>${t + 1}</sub> - ℓ<sub>${t}</sub>) + (1-β*)·b<sub>${t}</sub>
                </div>
                <div class="math-step">
                    b<sub>${t + 1}</sub> = ${betaStar.toFixed(2)} × (${l_t.toFixed(1)} - ${l_prev.toFixed(1)}) + ${(1 - betaStar).toFixed(2)} × ${b_prev.toFixed(1)}
                </div>
                <div class="math-step">
                    b<sub>${t + 1}</sub> = ${(betaStar * (l_t - l_prev)).toFixed(2)} + ${((1 - betaStar) * b_prev).toFixed(2)} = <span class="highlight">${b_t.toFixed(2)}</span>
                </div>
                <div class="math-step">
                    <strong>Next Forecast:</strong> ŷ<sub>${t + 2}|${t + 1}</sub> = ℓ<sub>${t + 1}</sub> + b<sub>${t + 1}</sub> = ${l_t.toFixed(1)} + ${b_t.toFixed(2)} = ${(l_t + b_t).toFixed(1)}
                </div>
            `;
            
            setTimeout(() => info.classList.remove('animating'), 500);
        }
        
        function updateTestForecast() {
            const testIndex = currentIteration - trainData.length;
            const lastLevel = levels[levels.length - 1];
            const lastTrend = trends[trends.length - 1];
            
            // For Holt's method, forecast h steps ahead uses: l_t + h * b_t
            const h = testIndex + 1;
            const forecast = lastLevel + h * lastTrend;
            forecasts.push(forecast);
            
            updateCharts();
            
            document.getElementById('currentStep').textContent = currentIteration + 1;
            currentIteration++;
            
            const speed = parseInt(document.getElementById('speed').value);
            animationId = setTimeout(animateStep, speed);
        }
        
        function updateInfoCards(step, level, trend) {
            document.getElementById('currentStep').textContent = step;
            document.getElementById('currentLevel').textContent = level.toFixed(1);
            document.getElementById('currentTrend').textContent = trend.toFixed(2);
            
            // Update trend indicator
            const indicator = document.getElementById('trendIndicator');
            if (trend > 0.5) {
                indicator.textContent = '↗';
                indicator.className = 'trend-indicator trend-up';
            } else if (trend < -0.5) {
                indicator.textContent = '↘';
                indicator.className = 'trend-indicator trend-down';
            } else {
                indicator.textContent = '→';
                indicator.className = 'trend-indicator trend-flat';
            }
        }
        
        function updateCharts() {
            // Show forecasts and components based on what's been calculated
            const trainForecastsToShow = forecasts.slice(0, Math.min(forecasts.length, trainData.length));
            const testForecastsToShow = forecasts.slice(trainData.length);
            const levelsToShow = levels;
            const trendsToShow = trends;
            
            // Main chart
            const traces = [
                {
                    x: trainTime,
                    y: trainData,
                    mode: 'lines+markers',
                    name: 'Training Data',
                    line: { color: 'blue', width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: testTime,
                    y: testData,
                    mode: 'lines+markers',
                    name: 'Test Data',
                    line: { color: 'lightblue', width: 2, dash: 'dash' },
                    marker: { size: 4 }
                },
                {
                    x: trainTime.slice(0, trainForecastsToShow.length),
                    y: trainForecastsToShow,
                    mode: 'lines+markers',
                    name: 'Fitted Values',
                    line: { color: 'red', width: 2 },
                    marker: { size: 6, symbol: 'circle-open' }
                }
            ];
            
            if (testForecastsToShow.length > 0) {
                traces.push({
                    x: testTime.slice(0, testForecastsToShow.length),
                    y: testForecastsToShow,
                    mode: 'lines+markers',
                    name: 'Forecasts (with trend!)',
                    line: { color: 'orange', width: 2 },
                    marker: { size: 6, symbol: 'square-open' }
                });
            }
            
            const layout1 = {
                title: 'Airline Passengers - Holt Linear Trend Method',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Number of Passengers' },
                showlegend: true,
                height: 400,
                hovermode: 'x'
            };
            
            Plotly.newPlot('mainChart', traces, layout1);
            
            // Level evolution chart - show only level component including initial value
            const levelXValues = levelsToShow.length > 0 ? [0, ...trainTime.slice(0, levelsToShow.length)] : [0];
            const levelYValues = levelsToShow.length > 0 ? [l0, ...levelsToShow] : [l0];
            
            const levelTrace = {
                x: levelXValues,
                y: levelYValues,
                mode: 'lines+markers',
                name: 'Level Component (ℓ_t)',
                line: { color: 'purple', width: 3 },
                marker: { size: 8, color: 'purple' },
                fill: 'tonexty',
                fillcolor: 'rgba(147, 112, 219, 0.1)'
            };
            
            const layout2 = {
                title: 'Level Component Evolution (ℓ_t)',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Level Value' },
                showlegend: true,
                height: 400,
                annotations: []
            };
            
            // Add annotation for initial value
            layout2.annotations.push({
                x: 0,
                y: l0,
                xref: 'x',
                yref: 'y',
                text: `ℓ₀ = ${l0.toFixed(1)}`,
                showarrow: true,
                arrowhead: 7,
                ax: -40,
                ay: 40,
                bgcolor: 'purple',
                bordercolor: 'purple',
                borderwidth: 2,
                font: { color: 'white' }
            });
            
            // Add annotation for current value if we have data
            if (levelsToShow.length > 0) {
                layout2.annotations.push({
                    x: trainTime[levelsToShow.length - 1],
                    y: levelsToShow[levelsToShow.length - 1],
                    xref: 'x',
                    yref: 'y',
                    text: `ℓ_${levelsToShow.length} = ${levelsToShow[levelsToShow.length - 1].toFixed(1)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: -50,
                    ay: -40,
                    bgcolor: 'purple',
                    bordercolor: 'purple',
                    borderwidth: 2,
                    font: { color: 'white' }
                });
            }
            
            Plotly.newPlot('levelChart', [levelTrace], layout2);
            
            // Trend evolution chart - including initial value
            const trendXValues = trendsToShow.length > 0 ? [0, ...trainTime.slice(0, trendsToShow.length)] : [0];
            const trendYValues = trendsToShow.length > 0 ? [b0, ...trendsToShow] : [b0];
            
            const trendTrace = {
                x: trendXValues,
                y: trendYValues,
                mode: 'lines+markers',
                name: 'Trend Component (b_t)',
                line: { color: 'green', width: 3 },
                marker: { size: 8, color: 'green' },
                fill: 'tozeroy',
                fillcolor: 'rgba(76, 175, 80, 0.1)'
            };
            
            const layout3 = {
                title: 'Trend Component Evolution (b_t)',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Trend Value', zeroline: true, zerolinewidth: 2, zerolinecolor: 'gray' },
                showlegend: true,
                height: 400,
                shapes: [{
                    type: 'line',
                    x0: 0,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: []
            };
            
            // Add annotation for initial value
            layout3.annotations.push({
                x: 0,
                y: b0,
                xref: 'x',
                yref: 'y',
                text: `b₀ = ${b0.toFixed(2)}`,
                showarrow: true,
                arrowhead: 7,
                ax: 40,
                ay: -40,
                bgcolor: 'green',
                bordercolor: 'green',
                borderwidth: 2,
                font: { color: 'white' }
            });
            
            // Add annotation for current value if we have data
            if (trendsToShow.length > 0) {
                layout3.annotations.push({
                    x: trainTime[trendsToShow.length - 1],
                    y: trendsToShow[trendsToShow.length - 1],
                    xref: 'x',
                    yref: 'y',
                    text: `b_${trendsToShow.length} = ${trendsToShow[trendsToShow.length - 1].toFixed(2)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 50,
                    ay: -40,
                    bgcolor: 'green',
                    bordercolor: 'green',
                    borderwidth: 2,
                    font: { color: 'white' }
                });
            }
            
            Plotly.newPlot('trendChart', [trendTrace], layout3);
            
            // Calculate and display metrics
            if (trainForecastsToShow.length > 0) {
                const trainErrors = trainForecastsToShow.map((f, i) => Math.pow(trainData[i] - f, 2));
                const trainRMSE = Math.sqrt(trainErrors.reduce((a, b) => a + b, 0) / trainErrors.length);
                document.getElementById('trainRMSE').textContent = trainRMSE.toFixed(1);
            }
            
            if (testForecastsToShow.length > 0) {
                const testErrors = testForecastsToShow.map((f, i) => Math.pow(testData[i] - f, 2));
                const testRMSE = Math.sqrt(testErrors.reduce((a, b) => a + b, 0) / testErrors.length);
                document.getElementById('testRMSE').textContent = testRMSE.toFixed(1);
            }
        }
        
        function startAnimation() {
            if (animationId) {
                pauseAnimation();
            }
            if (currentIteration === 0 || currentIteration >= trainData.length + testData.length) {
                resetVisualization();
            }
            animateStep();
        }
        
        function pauseAnimation() {
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        }
        
        function resetVisualization() {
            pauseAnimation();
            currentIteration = 0;
            levels = [];
            trends = [];
            forecasts = [];
            document.getElementById('currentStep').textContent = '0';
            document.getElementById('currentLevel').textContent = '-';
            document.getElementById('currentTrend').textContent = '-';
            document.getElementById('trendIndicator').textContent = '';
            document.getElementById('trainRMSE').textContent = '-';
            document.getElementById('testRMSE').textContent = '-';
            document.getElementById('iterationInfo').style.display = 'none';
            initializeCharts();
        }
        
        function showFullFit() {
            pauseAnimation();
            resetVisualization();
            
            // Clear existing arrays
            levels = [];
            trends = [];
            forecasts = [];
            
            // Initialize with starting values
            let currentLevel = l0;
            let currentTrend = b0;
            
            // Calculate full fit for training data
            for (let t = 0; t < trainData.length; t++) {
                const y_t = trainData[t];
                
                // Forecast for time t uses level and trend from t-1
                forecasts.push(currentLevel + currentTrend);
                
                // Update level after observing y_t
                const newLevel = alpha * y_t + (1 - alpha) * (currentLevel + currentTrend);
                
                // Update trend
                const newTrend = betaStar * (newLevel - currentLevel) + (1 - betaStar) * currentTrend;
                
                levels.push(newLevel);
                trends.push(newTrend);
                
                currentLevel = newLevel;
                currentTrend = newTrend;
            }
            
            // Add test forecasts with trend
            const lastLevel = levels[levels.length - 1];
            const lastTrend = trends[trends.length - 1];
            for (let h = 1; h <= testData.length; h++) {
                forecasts.push(lastLevel + h * lastTrend);
            }
            
            currentIteration = trainData.length + testData.length;
            updateCharts();
            showMetrics();
            updateInfoCards(trainData.length, lastLevel, lastTrend);
        }
        
        function showMetrics() {
            const trainForecasts = forecasts.slice(0, trainData.length);
            const testForecasts = forecasts.slice(trainData.length);
            
            if (trainForecasts.length > 0) {
                const trainErrors = trainForecasts.map((f, i) => Math.pow(trainData[i] - f, 2));
                const trainRMSE = Math.sqrt(trainErrors.reduce((a, b) => a + b, 0) / trainErrors.length);
                document.getElementById('trainRMSE').textContent = trainRMSE.toFixed(1);
            }
            
            if (testForecasts.length > 0) {
                const testErrors = testForecasts.map((f, i) => Math.pow(testData[i] - f, 2));
                const testRMSE = Math.sqrt(testErrors.reduce((a, b) => a + b, 0) / testErrors.length);
                document.getElementById('testRMSE').textContent = testRMSE.toFixed(1);
            }
        }
        
        function initializeCharts() {
            // Initial empty charts
            const traces1 = [
                {
                    x: trainTime,
                    y: trainData,
                    mode: 'lines+markers',
                    name: 'Training Data',
                    line: { color: 'blue', width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: testTime,
                    y: testData,
                    mode: 'lines+markers',
                    name: 'Test Data',
                    line: { color: 'lightblue', width: 2, dash: 'dash' },
                    marker: { size: 4 }
                }
            ];
            
            const layout1 = {
                title: 'Airline Passengers - Holt Linear Trend Method',
                xaxis: { title: 'Time (Months)' },
                yaxis: { title: 'Number of Passengers' },
                showlegend: true,
                height: 400
            };
            
            Plotly.newPlot('mainChart', traces1, layout1);
            
            // Show initial level l_0
            const levelTrace = {
                x: [0],
                y: [l0],
                mode: 'markers',
                name: 'Level Component (ℓ_t)',
                marker: { size: 10, color: 'purple' }
            };
            
            const layout2 = {
                title: 'Level Component Evolution (ℓ_t)',
                xaxis: { title: 'Time (Months)', range: [-1, trainData.length] },
                yaxis: { title: 'Level Value' },
                showlegend: true,
                height: 400,
                annotations: [{
                    x: 0,
                    y: l0,
                    xref: 'x',
                    yref: 'y',
                    text: `ℓ₀ = ${l0.toFixed(1)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: -40,
                    ay: 40,
                    bgcolor: 'purple',
                    bordercolor: 'purple',
                    borderwidth: 2,
                    font: { color: 'white' }
                }]
            };
            
            Plotly.newPlot('levelChart', [levelTrace], layout2);
            
            // Show initial trend b_0
            const trendTrace = {
                x: [0],
                y: [b0],
                mode: 'markers',
                name: 'Trend Component (b_t)',
                marker: { size: 10, color: 'green' }
            };
            
            const layout3 = {
                title: 'Trend Component Evolution (b_t)',
                xaxis: { title: 'Time (Months)', range: [-1, trainData.length] },
                yaxis: { title: 'Trend Value' },
                showlegend: true,
                height: 400,
                shapes: [{
                    type: 'line',
                    x0: -1,
                    x1: trainData.length,
                    y0: 0,
                    y1: 0,
                    line: { color: 'gray', width: 2, dash: 'dash' }
                }],
                annotations: [{
                    x: 0,
                    y: b0,
                    xref: 'x',
                    yref: 'y',
                    text: `b₀ = ${b0.toFixed(2)}`,
                    showarrow: true,
                    arrowhead: 7,
                    ax: 40,
                    ay: -40,
                    bgcolor: 'green',
                    bordercolor: 'green',
                    borderwidth: 2,
                    font: { color: 'white' }
                }]
            };
            
            Plotly.newPlot('trendChart', [trendTrace], layout3);
        }
        
        // Initialize on load
        initializeCharts();
    </script>
    
    <!-- Parameter Guide Section -->
    <div style="background: #f8f9fa; padding: 30px; margin-top: 20px; border-top: 3px solid #667eea;">
        <div style="max-width: 1000px; margin: 0 auto;">
            <h2 style="color: #667eea; text-align: center; margin-bottom: 25px; font-size: 1.8em;">
                📚 Parameter Guide: Understanding Alpha (α) and Beta* (β*)
            </h2>
            
            <div style="background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px;">
                <h3 style="color: #333; margin-bottom: 20px; font-size: 1.3em;">🎯 Dual Parameter Control: Level and Trend Components</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                    <div style="background: #fff8f0; padding: 20px; border-radius: 8px; border-left: 4px solid #ff8c00;">
                        <h4 style="color: #ff8c00; margin-bottom: 12px;">📊 Alpha (α) - Level Smoothing</h4>
                        <p style="margin: 0 0 10px 0; line-height: 1.6; color: #555;">
                            <strong>Controls level responsiveness:</strong>
                        </p>
                        <ul style="margin: 0; padding-left: 20px; color: #555;">
                            <li><strong>Low α (0.1-0.3):</strong> Stable level, slow to adapt</li>
                            <li><strong>High α (0.7-0.9):</strong> Responsive level, quick adaptation</li>
                        </ul>
                    </div>
                    
                    <div style="background: #f0f8ff; padding: 20px; border-radius: 8px; border-left: 4px solid #4169e1;">
                        <h4 style="color: #4169e1; margin-bottom: 12px;">📈 Beta* (β*) - Trend Smoothing</h4>
                        <p style="margin: 0 0 10px 0; line-height: 1.6; color: #555;">
                            <strong>Controls trend responsiveness:</strong>
                        </p>
                        <ul style="margin: 0; padding-left: 20px; color: #555;">
                            <li><strong>Low β* (0.1-0.3):</strong> Stable trend, resistant to noise</li>
                            <li><strong>High β* (0.7-0.9):</strong> Adaptive trend, follows changes</li>
                        </ul>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div style="background: #f0fff4; padding: 20px; border-radius: 8px; border-left: 4px solid #22c55e;">
                        <h4 style="color: #22c55e; margin-bottom: 10px;">⚡ High α, Low β*</h4>
                        <p style="margin: 0; line-height: 1.6; color: #555;">
                            Level adapts quickly to changes, but trend remains stable. Good for data with level shifts but consistent trend direction.
                        </p>
                    </div>
                    
                    <div style="background: #fdf2f8; padding: 20px; border-radius: 8px; border-left: 4px solid #ec4899;">
                        <h4 style="color: #ec4899; margin-bottom: 10px;">🔄 Low α, High β*</h4>
                        <p style="margin: 0; line-height: 1.6; color: #555;">
                            Level changes slowly, but trend adapts quickly. Useful when trend direction changes frequently but level is stable.
                        </p>
                    </div>
                </div>
                
                <div style="background: #fffbeb; padding: 20px; border-radius: 8px; border-left: 4px solid #f59e0b; margin-bottom: 20px;">
                    <h4 style="color: #f59e0b; margin-bottom: 10px;">🎯 Forecast Impact: ŷ<sub>t+h|t</sub> = ℓ<sub>t</sub> + h·b<sub>t</sub></h4>
                    <p style="margin: 0; line-height: 1.6; color: #555;">
                        The forecast combines both components: the current level plus the trend multiplied by the forecast horizon. 
                        <strong>Longer horizons amplify the trend effect</strong>, making β* increasingly important for long-term forecasts. 
                        A stable trend (low β*) produces consistent long-term forecasts, while an adaptive trend (high β*) can lead to dramatic fan-out effects.
                    </p>
                </div>
                
                <div style="background: #f0f9ff; padding: 20px; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                    <h4 style="color: #0ea5e9; margin-bottom: 10px;">🔬 Component Independence</h4>
                    <p style="margin: 0; line-height: 1.6; color: #555;">
                        Unlike SES where only α matters, Holt's method allows independent control over how quickly the model adapts its understanding of 
                        <em>"where we are"</em> (level) versus <em>"where we're going"</em> (trend). This dual-parameter approach enables much more nuanced 
                        modeling of trending time series patterns.
                    </p>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px; color: #666; font-style: italic;">
                Experiment with different α and β* combinations above to see how they independently control level and trend adaptation!
            </div>
        </div>
    </div>
</body>
</html>